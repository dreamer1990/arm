本次课主要内容:
    宏定义
    文件包含处理
    条件编译


预处理：
	
	一个源文件生成二进制可执行文件步骤：
		1 预处理：
			gcc -E 1.c -o 1.i
			头文件 宏命令 条件编译 特殊字符
		2 编译：汇编代码
			gcc -S 1.i -o 1.s
			语法规则和词法错误
		3 汇编：目标代码 二进制不可以执行
			gcc -c 1.s -o 1.o
		4 链接：
			gcc 1.o -o hello
			链接共享动态库

1. 基本概念

	ANSI C标准规定可以在Ｃ源程序中加入一些“预处理命令” ，以改进程序设计环境，提高编程效率。

	这些预处理命令是由ANSI C统一规定的，但是它不是C语言本身的组成部分，不能直接对它们进行编译（因为编译程序不能识别它们）。必须在对程序进行通常的编译之前，先对程序中这些特殊的命令进行“预处理”。

	经过预处理后程序可由编译程序对预处理后的源程序进行通常的编译处理，得到可供执行的目标代码。 

	C语言与其他高级语言的一个重要区别是可以使用预处理命令和具有预处理的功能。
	Ｃ提供的预处理功能主要有以下三种：
　  	(１)．宏定义
　　	(２)．文件包含
　　	(３)．条件编译
	 这些功能分别用宏定义命令、文件包含命令、条件编译命令来实现。为了与一般Ｃ语句相区别，这些命令以符号“#”开头。例如：
	 #define 
	 #include 
     #if


2. 宏定义
	a. 不带参数的宏定义
	宏定义一般形式为:
		#define 标识符 字符串
		例如：# define PI 3.1415926

	宏定义的作用是在本程序文件中用指定的标识符PI来代替“3.1415926”这个字符串，在编译预处理时，将程序中在该命令以后出现的所有的PI都用“3.1415926”代替。这种方法使用户能以一个简单的名字代替一个长的字符串。
	这个标识符（名字）称为“宏名”。
	在预编译时将宏名替换成字符串的过程称为“宏展开”。#define是宏定义命令。


	说明:
	(1) 宏名一般习惯用大写字母表示，以便与变量名相区别。但这并非规定，也可用小写字母。
	(2) 使用宏名代替一个字符串，可以减少程序中重复书写某些字符串的工作量。
	(3) 宏定义是用宏名代替一个字符串，只作简单置换，不作正确性检查。只有在编译已被宏展开后的源程序时才会发现语法错误并报错。
	(4) 宏定义不是Ｃ语句，不必在行末加分号。如果加了分号则会连分号一起进行置换。
	(5) #define命令出现在程序中函数的外面，宏名的有效范围为定义命令之后到本源文件结束。通常，#define命令写在文件开头，函数之前，作为文件一部分，在此文件范围内有效。
	(6) 可以用#undef命令终止宏定义的作用域。
	(7) 在进行宏定义时，可以引用已定义的宏名，可以层层置换。 
	(8) 对程序中用双撇号括起来的字符串内的字符，即使与宏名相同，也不进行置换。 
	(9) 宏定义是专门用于预处理命令的一个专用名词，它与定义变量的含义不同，只作字符替换，不分配内存空间。

	b. 带参数的宏定义
	作用：不是进行简单的字符串替换，还要进行参数替换。 
	
	带参数的宏定义一般形式为:

	#define 宏名（参数表）  字符串 
		字符串中包含在括弧中所指定的参数

	说明：
	(1)对带参数的宏展开只是将语句中的宏名后面括号内的实参字符串代替#define 命令行中的形参。
	(2) 在宏定义时，在宏名与带参数的括弧之间不应加空格，否则将空格以后的字符都作为替代字符串的一部分。 

	带参数的宏和函数的区别:
    (1) 函数调用时，先求出实参表达式的值，然后代入形参。而使用带参的宏只是进行简单的字符替换。
    (2) 函数调用是在程序运行时处理的，为形参分配临时的内存单元。而宏展开则是在编译前进行的，在展开时并不分配内存单元，不进行值的传递处理，也没有“返回值”的概念。
    (3) 对函数中的实参和形参类型要求一致。而宏名无类型，它的参数也无类型，只是一个符号代表，展开时代入指定的字符串即可。宏定义时，字符串可以是任何类型的数据。
    (4) 调用函数只可得到一个返回值，而用宏可以设法得到几个结果。 
    (5) 使用宏次数多时，宏展开后源程序长，因为每展开一次都使程序增长，而函数调用不会使源程序变长。
    (6) 宏替换不占运行时间，只占编译时间。而函数调用则占运行时间（分配单元、保留现场、值传递、返回）。
    

	如果善于利用宏定义，可以实现程序的简化，如事先将程序中的“输出格式”定义好，以减少在输出语句中每次都要写出具体的输出格式的麻烦。

    通过宏展开得到若干个结果
    #include <stdio.h>
    #define PR printf
    #define NL "\n"
    #define D "%d"
    #define D1 D NL
    #define D2 D D NL
    #define D3 D D D NL
    #define D4 D D D D NL
    #define S "%s"


3. 文件包含处理
	所谓“文件包含”处理是指一个源文件可以将另外一个源文件的全部内容包含进来。Ｃ语言提供了#include命令用来实现“文件包含”的操作。
	其一般形式为:
	 #include "文件名"
	或 #include <文件名>

	<>:只会从系统头文件目录中查找
	"":先从当前工作目录中查找，如果当前工作目录中不存在，则从系统头文件目录中查找

	头文件：.h格式文件

	为了防止头文件重复包含
	#ifndef __HELLO_H__
	#define __HELLO_H__

	#endif


	说明:
    (1) 一个#include命令只能指定一个被包含文件，如果要包含ｎ个文件，要用ｎ个#include命令。
    (2) 如果文件１包含文件２，而在文件２中要用到文件３的内容，则可在文件１中用两个include命令分别包含文件２和文件３，而且文件３应出现在文件２之前，即在file1.c中定义。
    (3) 在一个被包含文件中又可以包含另一个被包含文件，即文件包含是可以嵌套的。 
    (4) 在#include命令中，文件名可以用双引号或尖括号括起来。
    (5) 被包含文件（file2.h）与其所在的文件（即用#include命令的源文件file2.c），在预编译后已成为同一个文件（而不是两个文件）。因此，如果file2.h中有全局静态变量，它也在file1.h文件中有效，不必用extern声明。 

4. 宏相关的一些调试技巧
	__LINE__    代表当前所在行
	__func__    代表当前所在的函数
	__TIME__    代表当前的时间
	__DATE__    代表当前的日期
	__FILE__    代表当前所在的文件

    

5. 条件编译
	概念：所谓“条件编译”，是对部分内容指定编译的条件，使其只在满足一定条件才进行编译。

        条件编译命令的几种形式：
        (1)#ifdef 标识符
               程序段１
        　#else
               程序段２
        　#endif
        
        (2)#ifndef 标识符
               程序段１
        　#else
               程序段２
        　#endif
        
        (3) #if 表达式
                程序段１
        　　#else
                程序段２
        　　#endif
        
6. Makefile

    make命令
        -f 指定文件当作Makefile
        -i 忽略错误
        -C 进入指定的目录,然后执行make命令
        -s 安静的模式

    make 规则:
    
    当依赖比目标"新"时执行命令.
    基本规则:
    target: prerequisite
    <TAB>command
    
    a. 多目标:
    file1.o file2.o : source1.c source2.c source3.c
    <TAB>command
    
    b. 伪目标:
    .PHONY: help
    help:
    <TAB>command
    
    c. 模式规则:
    %: make中使用的通配符号, 代表柄(stem).
    例如, 想使用add.c sub.c生成add.o和sub.o, 即可使用此规则
    %.o : %.c
    <TAB>command
    
    d. 限制的模式规则:
    和模式规则一样, 但是目标只有a.o和b.o
    a.o b.o : %.o : %.c
    <TAB>command
    


     变量定义:
     --------------------------------
     延后赋值: 变量被引用时才赋值
     var = str
     
     立即赋值
     var := str
     
     追加赋值: 给变量追加值, 如果变量原来是立即赋值的,
     则追加也是立即的; 否则为延后追加赋值.
     var += str
     
     条件赋值: 变量没有定义则使用该赋值.
     var ?= str
     
     
     变量引用:
     --------------------------------
     使用$(var)形式或者${var}形式引用变量. makefile中一般
     只使用$(var)形式.
     注意: shell脚本只使用${var}形式引用变量, shell脚本中
     $(command)表示命令替换, 即执行command命令并可将命令输出
     赋值给某shell变量.
     makefile是make解析的, 和shell脚本是两回事.
     
     
     一个 := 与 = 区别的例子:
     --------------------------------
     CC := gcc
     CFLAGS := -g
     CCOMP = $(CC) $(CFLAGS)
     $(info Compiler is $(CCOMP))
     
     CC := arm-linux-gcc
     $(info Compiler is $(CCOMP))
     
     
     内置变量:
     --------------------------------
     $@ 规则目标
     $< 规则依赖中第一个预备文件
     $^ 规则依赖中所有预备文件的完整清单
     
     $(@D) 规则目标文件的所在目录
     $(@F) 规则目标文件的文件名
     
     
     变量高级用法:
     --------------------------------
     foo := a.o b.o c.o
     var := $(foo:.o=.c)
     
     替换后变量var的值是 a.c b.c c.c
     

7. gdb

    编译:
        gcc -g 1test.c -o test
    启动调试:
        gdb test

    list: 默认列出10行程序
        list -10 往前看10行
        list first  第一行
        list last   最后一行

    break:设置断点  
        break 16    在16行设置断点
        break fun   在函数fun出设置断点 
        info break  查看断点信息
        run         运行程序
        next        单步
        continue    继续运行程序
        print       打印变量的值
        bt          查看函数的堆栈
        
        quit        退出

    
        

    

