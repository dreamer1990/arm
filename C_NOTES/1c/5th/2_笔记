本次课内容：
	指针初级

1. 指针的概念
	
	内存区的每一个字节有一个编号，这就是“地址”，它相当于旅馆中的房间号。
	在地址所标识的内存单元中存放数据，这相当于旅馆房间中居住的旅客一样。
	由于通过地址能找到所需的变量单元，我们可以说，地址指向该变量单元。
	将地址形象化地称为“指针”
	
	一个变量的地址称为该变量的“指针”
	如果有一个变量专门用来存放另一变量的地址（即指针），则它称为“指针变量”

2. 指针变量

	定义指针变量的一般形式为：
		类型  * 指针变量名;
		如：int *pointer_1, *pointer_2;
		说明：
		int是为指针变量指定的“基类型”
		基类型指定指针变量可指向的变量类型
		如pointer_1可以指向整型变量，但不能指向浮点型变量

	引用指针变量：

	在引用指针变量时，可能有三种情况：
	a. 给指针变量赋值。如：p=&a;
	b. 引用指针变量指向的变量。如有
		p=&a;  *p=1;
		则执行printf(“%d”,*p);  将输出1
	c. 引用指针变量的值。如：printf(“%o”,p);
	
	运算符：
	(1) ＆  取地址运算符。
		&a是变量a的地址
	(2) *  指针运算符（“间接访问”运算符）
		如果： p指向变量a，则*p就代表a。
		k=*p;       (把a的值赋给k)
		*p=1;       (把1赋给a)

3. 指针变量与函数

4. 数组与指针

	数组元素的指针：
	a. 一个变量有地址，一个数组包含若干元素，每个数组元素都有相应的地址
	b. 指针变量可以指向数组元素（把某一元素的地址放到一个指针变量中）
	c. 所谓数组元素的指针就是数组元素的地址

	引用数组元素时指针的运算:
	在指针指向数组元素时，允许以下运算：
	a. 加一个整数(用+或+=)，如p+1
	b. 减一个整数(用-或-=)，如p-1
	c. 自加运算，如p++，++p
	d. 自减运算，如p--，--p
	e. 两个指针相减，如p1-p2 (只有p1和p2都指向同一数组中的元素时才有意义)

	(1) 如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素，p-1指向同一数组中的上一个元素。
	举例:
	float a[10],*p=a;
	假设a[0]的地址为2000，则
	p的值为2000
	p+1的值为2004
	P-1的值为1996
	
	(2) 如果ｐ的初值为&a[0]，则p+i和a+i就是数组元素a[i]的地址，或者说，它们指向a数组序号为i的元素

	(3)  *(p+i)或*(a+i)是p+i或a+i所指向的数组元素，即a[i]。

	(4) 如果指针p1和p2都指向同一数组

		p2-p1的值是4
		不能p1+p2

	通过指针引用数组元素：
	引用一个数组元素，可用下面两种方法： 
   （１） 下标法，如a[i]形式
   （２） 指针法，如*(a+i)或*(p+i)
		其中a是数组名，p是指向数组元素的指针变量，其初值p=a


5. 动态内存分配

    calloc
    void *calloc(size_t nmemb, size_t size);
    功能: 分配内存空间,将分配的内存初始化为0
    参数:
        nmemb: 元素的个数
        size:  每个元素的大小
    返回值:
        成功: 返回分配内存的首地址
        失败: 返回NULL

    malloc
    void *malloc(size_t size);
        功能: 分配内存空间        
        size: 分配size个字节的内存,分配的内存在堆上 
        返回值:
            成功: 返回分配内存的首地址
            失败: 返回NULL

    free
    void free(void *ptr);
        功能:释放内存
        ptr: 通过malloc calloc realloc分配的内存的首地址
        返回值:没有返回值
            
    realloc
    void *realloc(void *ptr, size_t size);
        功能: 增加分配内存
        参数:
            ptr 原来内存的首地址
            size 要改变的大小
        返回值:
            成功 返回新内存的首地址
            失败 NULL 

        说明:
            ptr为NULL, 等价于malloc(size)
            size为0, 等价于free(p)
            如果ptr被移动了 会自动调用free释放原来的内存 









