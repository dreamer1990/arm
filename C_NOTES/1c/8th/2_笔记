本次课内容

指针(四)
	1. 结构体
	2. 联合体
	3. 枚举
	4. 指针


1. 结构体
	用户自己建立由不同类型数据组成的组合型的数据结构，它称为结构体
	例如，一个学生的学号、姓名、性别、年龄、成绩、家庭地址等项，是属于同一个学生的，因此组成一个组合数据，如student_1的变量，反映它们之间的内在联系

	声明一个结构体类型的一般形式为：
          struct  结构体名
          {  成员表列  }; 
	说明：

	(1)结构体类型并非只有一种，而是可以设计出许多种结构体类型，例如
	struct Teacher
	struct Worker
	struct Date等结构体类型
	各自包含不同的成员

	(2) 成员可以属于另一个结构体类型。
	 struct Date 　　　
	{   
        int month;  
        int day;  
        int year; 
    };
	struct Stu  
	{   
        int num;
        char name[20];
        char sex;
        int age;
        struct Date birthday;  
        char addr[30]; 
	};


	前面只是建立了一个结构体类型，它相当于一个模型，并没有定义变量，其中并无具体数据，系统对之也不分配存储单元。
	相当于设计好了图纸，但并未建成具体的房屋。为了能在程序中使用结构体类型的数据，应当定义结构体类型的变量，并在其中存放具体的数据。

2. 结构体变量的定义

	(1). 先声明结构体类型，再定义该类型变量
	声明结构体类型struct Student，可以用它来定义变量
	struct Student  student1,student2;


	(2).在声明类型的同时定义变量
    struct Student
    {  
        int num; 
        char name[20]; 
        char sex; 
        int age;  
        float score; 
        char addr[30]; 
    }student1,student2;


	(3). 不指定类型名而直接定义结构体类型变量
	其一般形式为:
       struct
       { 成员表列 }变量名表列; 
	指定了一个无名的结构体类型 。


	说明:
	(1) 结构体类型与结构体变量是不同的概念，不要混同。只能对变量赋值、存取或运算，而不能对一个类型赋值、存取或运算。在编译时，对类型是不分配空间的，只对变量分配空间。

	(2) 结构体类型中的成员名可以与程序中的变量名相同，但二者不代表同一对象。
	(3) 对结构体变量中的成员（即“域”），可以单独使用，它的作用与地位相当于普通变量。


3. 结构体的初始化和引用

	(1) 在定义结构体变量时可以对它的成员进行初始化。

	(2) 可以引用结构体变量中成员的值,引用方式为 结构体变量名.成员名

	(3) 如果成员本身有属于一个结构体类型,则要用若干个成员运算符,一级一级的找到最低一级的成员。

	(4) 对结构体变量的成员可以像普通变量一样进行各种运算。

	(5) 同类结构体可以相互赋值

	(6) 可以引用结构体变量成员的地址, 也可以引用结构体变量的地址

4. 结构体数组

	struct Person               
	{  
	    char name[20];       
		int count;                   
	}leader[3]={“Li”,0,“Zhang”,0,“Sun”,0};   

    (1) 定义结构体数组一般形式是
    ① struct 结构体名
        {成员表列} 数组名[数组长度];

    ② 先声明一个结构体类型，然后再用此类型定义结构体数组：
         结构体类型  数组名[数组长度];
       如：
         struct Person  leader[3]; 
    
    (2)对结构体数组初始化的形式是在定义数组的后面加上：
        ＝｛初值表列｝; 
        如：
        struct Person  leader[3]= {"Li",0,"Zhang",0,"Fun",0}; 
    

5. 结构体指针

	指向结构体对象的指针变量既可以指向结构体变量，也可以用来指向结构体数组中的元素。
	指针变量的基类型必须与结构体变量的类型相同。例如：
	struct Student *pt; 

    struct Student
    { 
        long num;
        char name[20];
        char sex;
        float score;
    };
    
    说明：
    为了使用方便和直观，C语言允许把(*p).num用p->num来代替
    (*p).name等价于p->name
    如果p指向一个结构体变量stu，以下等价：
    ①  stu.成员名(如stu.num)
    ②  (*p).成员名(如(*p).num)
         p->成员名(如p->num)


6. 结构体数组的指针

    struct Student                  
    { 
        int num;    
        char name[20];
        char sex;   
        int age;
    };

    struct Student stu[3]=
    {
         {10101,"Li Lin",'M',18},
         {10102,"Zhang Fun",'M',19},
         {10104,"Wang Min",'F',20} 
    };
    
    struct Student *p;  
    printf(" No.  Name         sex  age\n");
    for(p=stu;p<stu+3;p++)
        printf(“%5d %-20s %2c %4d\n”,
                               p->num, p->name, 
                                    p->sex, p->age); 
    


7. 结构体变量和结构体变量的指针作函数参数
    (1) 用结构体变量的成员作参数。
      例如，用stu[1].num或stu[2].name作函数实参，将实参值传给形参。
        用法和用普通变量作实参是一样的，属于“值传递”方式。
        应当注意实参与形参的类型保持一致。
    
    (2) 用结构体变量作实参。
        用结构体变量作实参时，将结构体变量所占的内存单元的内容全部按顺序传递给形参，形参也必须是同类型的结构体变量
        在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大
        在被调用函数期间改变形参（也是结构体变量）的值，不能返回主调函数
        一般较少用这种方法
    
    (3)用指向结构体变量（或数组元素）的指针作实参，将结构体变量（或数组元素）的地址传给形参。


8. 共用体
 (1) 基本概念
    有时想用同一段内存单元存放不同类型的变量。
    使几个不同的变量共享同一段内存的结构，称为 “共用体”类型的结构。

    定义共用体类型变量的一般形式为：
    union　共用体名
    { 成员表列
    }变量表列； 
    例如：
    union Data
    {   
        int i;
        char ch;
        float f; 
    }a,b,c; 
    
 (2) 共用体与结构体的区别
“共用体”与“结构体”的定义形式相似，但它们的含义是不同的。
结构体变量所占内存长度是各成员占的内存长度之和，每个成员分别占有其自己的内存单元。而共用体变量所占的内存长度等于最长的成员的长度。


只有先定义了共用体变量才能引用它，但应注意，不能引用共用体变量，而只能引用共用体变量中的成员。
例如，前面定义了a,b,c为共用体变量，下面的引用方式是正确的：
          a.i    a.ch    a.f 

 (3) 共用体数据类型的特点

在使用共用体类型数据时要注意以下一些特点：
    a.  同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员，而不是同时存放几个。
    b.可以对共用体变量初始化，但初始化表中只能有一个常量。
    c. 共用体变量中起作用的成员是最后一次被赋值的成员，在对共用体变量中的一个成员赋值后，原有变量存储单元中的值就取代。
    d. 共用体变量的地址和它的各成员的地址都是同一地址。
    e. 不能对共用体变量名赋值，也不能企图引用变量名来得到一个值。
    f. 以前的C规定不能把共用体变量作为函数参数，但可以使用指向共用体变量的指针作函数参数。C99允许用共用体变量作为函数参数。
    g. 共用体类型可以出现在结构体类型定义中，也可以定义共用体数组。反之，结构体也可以出现在共用体类型定义中，数组也可以作为共用体的成员。


9. 枚举

如果一个变量只有几种可能的值，则可以定义为枚举类型
所谓“枚举”就是指把可能的值一一列举出来，变量的值只限于列举出来的值的范围内


声明枚举类型用enum开头。
    例如：
    enum Weekday{sun,mon,tue,wed,thu,fri,sat};
    声明了一个枚举类型enum Weekday
    然后可以用此类型来定义变量
    enum Weekday  workday,weekend;

    workday=mon;        正确
    weekend=sun;        正确
    weekday=monday;     不正确


说明:
(1) C编译对枚举类型的枚举元素按常量处理，故称枚举常量。不要因为它们是标识符(有名字)而把它们看作变量，不能对它们赋值。例如: 
     sun=0; mon=1;   错误


(2) 每一个枚举元素都代表一个整数，Ｃ语言编译按定义时的顺序默认它们的值为0,1,2,3,4,5…
在上面定义中，sun的值为0，mon的值为1,…sat的值为6
如果有赋值语句: workday=mon; 
   相当于workday=1;

也可以人为地指定枚举元素的数值，例如: 
    enum Weekday{sun=7,mon=1,tue,wed,thu,fri,sat}workday,week_end; 
指定枚举常量sun的值为7，mon为1，以后顺序加1，sat为6。

(3) 枚举元素可以用来作判断比较。例如： 
if(workday==mon)
if(workday>sun)
枚举元素的比较规则是按其在初始化时指定的整数来进行比较的。
如果定义时未人为指定，则按上面的默认规则处理，即第一个枚举元素的值为０，故mon>sun，sat>fri


10. typedef的用法

(1).简单地用一个新的类型名代替原有的类型名
    typedef int Integer; 
    typedef float  Real;
    int i,j;  float a,b; 与
    Integer i,j；  Real a,b;等价

(2).命名一个简单的类型名代替复杂的类型表示方法

a. 命名一个新的类型名代表结构体类型： 
typedef struct
{ 
    int month; 
    int day; 
    int year; 
}Date;
Date birthday; 
Date *p;  

(b) 命名一个新的类型名代表数组类型
typedef int Num[100]; 
Num a; 

(c)命名一个新的类型名代表一个指针类型
typedef char *String;   
String p,s[10]; 

(d)命名一个新的类型名代表指向函数的指针类型
typedef int (*Pointer)(void);
Pointer p1,p2; 

总结：
归纳起来，声明一个新的类型名的方法是
① 先按定义变量的方法写出定义体（int i;）
② 将变量名换成新类型名（将i换成Count）
③ 在最前面加typedef
        （typedef int Count）
④ 用新类型名去定义变量

以定义上述的数组类型为例来说明：
① 先按定义数组变量形式书写：int a[100];
② 将变量名a换成自己命名的类型名：int Num[100];
③ 在前面加上typedef，得到typedef int Num[100];
用来定义变量：Num a;          
相当于定义了：int a[100];


对字符指针类型，也是：
char *p；                     
char *String; 
typedef char *String; 
String p;  //与char *p等价


说明：
(1)以上的方法实际上是为特定的类型指定了一个同义字(synonyms)。例如
①   typedef int Num[100]; 
    Num a;       Num是int [100]的同义词
②   typedef int (*Pointer)(void);
    Pointer  p1;  Pointer是int (*)(void)的同义词

(2)用typedef只是对已经存在的类型指定一个新的类型名，而没有创造新的类型。
(3)用typedef声明数组类型、指针类型，结构体类型、共用体类型、枚举类型等，使得编程更加方便。
(4)typedef与#define表面上有相似之处，实际上typedef是在编译阶段处理的，#define是在预编译时处理的
(5) 当不同源文件中用到同一类型数据时，常用typedef声明一些数据类型。可以把所有的typedef名称声明单独放在一个头文件中，然后在需要用到它们的文件中用#include指令把它们包含到文件中。这样编程者就不需要在各文件中自己定义typefef名称了。

(6) 使用typedef名称有利于程序的通用与移植。有时程序会依赖于硬件特性，用typedef类型就便于移植。


