
面向对象程序设计有4个主要特点: 抽象、封装、继承和多态性。

1. 运算符重载
 1.1 什么是运算符重载

	所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能。

	运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。

	通过函数来实现复数相加。
	#include <iostream>
	using namespace std;
	class Complex                                     //定义Complex类
	{public:
	Complex( ){real=0;imag=0;}                      //定义构造函数
	Complex(double r,double i){real=r;imag=i;}     //构造函数重载
	Complex complex_add(Complex &c2);              //声明复数相加函数
	void display( );                                //声明输出函数
	 private:
	double real;                                   //实部
	double imag;                                   //虚部
	};

	Complex Complex∷complex_add(Complex &c2)
	{Complex c;
	c.real=real+c2.real;
	c.imag=imag+c2.imag;
	return c;}   

	void Complex∷display( )                            //定义输出函数
	{cout<<″(″<<real<<″,″<<imag<<″i)″<<endl;}

	int main( )
	{Complex c1(3,4),c2(5,-10),c3;                     //定义3个复数对象
	c3=c1.complex_add(c2);                            //调用复数相加函数
	cout<<″c1=″; c1.display( );                        //输出c1的值
	cout<<″c2=″; c2.display( );                        //输出c2的值
	cout<<″c1+c2=″; c3.display( );                     //输出c3的值
	return 0;
	}
	运行结果如下： 
	c1=(3+4i)
	c2=(5-10i)
	c1+c2=(8,-6i)

 1.2 运算符重载的方法

	运算符重载的方法是定义一个重载运算符的函数，在需要执行被重载的运算符时，系统就自动调用该函数，以实现相应的运算。也就是说，运算符重载是通过定义函数实现的。运算符重载实质上是函数的重载。
	
	重载运算符的函数一般格式如下： 
	函数类型 operator 运算符名称 (形参表列)
	{ 对运算符的重载处理 }

	例如，想将“+”用于Complex类(复数)的加法运算，函数的原型可以是这样的： 
	Complex operator+ (Complex& c1,Complex& c2);

	重载运算符“+”，使之能用于两个复数相加。
	#include <iostream>
	using namespace std;
	class Complex
	{public:
	Complex( ){real=0;imag=0;}
	Complex(double r,double i){real=r;imag=i;}
	Complex operator+(Complex &c2);               //声明重载运算符的函数
	void display( );
	 private:
	double real;
	double imag;
	};
	Complex Complex∷operator+(Complex &c2)          //定义重载运算符的函数
	{ Complex c;
	c.real=real+c2.real;
	c.imag=imag+c2.imag;
	return c;}

	void Complex∷display( )
	{ cout<<″(″<<real<<″,″<<imag<<″i)″<<endl;}

	int main( )
	{ Complex c1(3,4),c2(5,-10),c3;
	c3=c1+c2;                                     //运算符+用于复数运算
	cout<<″c1=″;c1.display( );
	cout<<″c2=″;c2.display( );
	cout<<″c1+c2=″;c3.display( );
	return 0;
	}
	运行结果与例10.1相同： 
	c1=(3+4i)
	c2=(5-10i)
	c1+c2=(8,-6i)

	需要说明的是： 运算符被重载后，其原有的功能仍然保留，没有丧失或改变。


 1.3 重载运算符的规则

	(1) C++不允许用户自己定义新的运算符，只能对已有的C++运算符进行重载。

	(2） C++允许重载的运算符
	C++中绝大部分的运算符允许重载。
	不能重载的运算符只有5个： 
	.        (成员访问运算符)
	->       (成员指针访问运算符)
	::      (域运算符)
	sizeof   (长度运算符)
	?:       (条件运算符)

	前两个运算符不能重载是为了保证访问成员的功能不能被改变，域运算符和sizeof运算符的运算对象是类型而不是变量或一般表达式，不具重载的特征。
	(3) 重载不能改变运算符运算对象(即操作数)的个数。
	(4) 重载不能改变运算符的优先级别。
	(5) 重载不能改变运算符的结合性。
	(6) 重载运算符的函数不能有默认的参数，否则就改变了运算符参数的个数，与前面第(3)点矛盾。
	(7) 重载的运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象(或类对象的引用)。也就是说，参数不能全部是C++的标准类型，以防止用户修改用于标准类型数据的运算符的性质。
	(8) 用于类对象的运算符一般必须重载，但有两个例外，运算符“=”和“&”不必用户重载。
	① 赋值运算符(=)可以用于每一个类对象，可以利用它在同类对象之间相互赋值。
	② 地址运算符&也不必重载，它能返回类对象在内存中的起始地址。
	(9) 应当使重载运算符的功能类似于该运算符作用于标准类型数据时所实现的功能。
	(10) 运算符重载函数可以是类的成员函数，也可以是类的友元函数，还可以是既非类的成员函数也不是友元函数的普通函数。


 1.4 运算符重载函数作为类成员函数和友元函数

	将运算符“+”重载为适用于复数加法，重载函数不作为成员函数，而放在类外，作为Complex类的友元函数。
	#include <iostream>
	using namespace std;
	class Complex
	{public:
	Complex( ){real=0;imag=0;}
	Complex(double r,double i){real=r;imag=i;}
	friend Complex operator + (Complex &c1,Complex &c2);//重载函数作为友元函数
	void display( );
	 private:
	double real;
	double imag;
	};

	Complex operator + (Complex &c1,Complex &c2)          //定义作为友元函数的重载函数
	{return Complex(c1.real+c2.real, c1.imag+c2.imag);}

	void Complex∷display( )
	{cout<<″(″<<real<<″,″<<imag<<″i)″<<endl;}
	int main( )
	{Complex c1(3,4),c2(5,-10),c3;
	c3=c1+c2;
	cout<<″c1=″; c1.display( );
	cout<<″c2=″; c2.display( );
	cout<<″c1+c2 =″; c3.display( );
	}

	C++规定，有的运算符(如赋值运算符、下标运算符、函数调用运算符)必须定义为类的成员函数，有的运算符则不能定义为类的成员函数(如流插入“<<”和流提取运算符“>>”、类型转换运算符)。

	由于友元的使用会破坏类的封装，因此从原则上说，要尽量将运算符函数作为成员函数。但考虑到各方面的因素，一般将单目运算符重载为成员函数，将双目运算符重载为友元函数。

 1.5 重载双目运算符

 1.6 重载单目运算符


2. 继承与派生的概念

	在C++中可重用性是通过继承(inheritance)这一机制来实现的。继承是C++的一个重要组成部分。
	一个类中包含了若干数据成员和成员函数。在不同的类中，数据成员和成员函数是不相同的。但有时两个类的内容基本相同或有一部分相同。
	利用原来声明的类Student作为基础，再加上新的内容即可，以减少重复的工作量。 C++提供的继承机制就是为了解决这个问题。

	在C++中，所谓“继承”就是在一个已存在的类的基础上建立一个新的类。已存在的类(例如“马”)称为“基类(base class)”或“父类(father class)”。新建立的类(例如“公马”)称为“派生类(derived class)”或“子类(son class)”。


	一个新类从已有的类那里获得其已有特性，这种现象称为类的继承。通过继承，一个新建子类从已有的父类那里获得父类的特性。从另一角度说，从已有的类(父类)产生一个新的子类，称为类的派生。类的继承是用已有的类来建立专用类的编程技术。派生类继承了基类的所有数据成员和成员函数，并可以对成员作必要的增加或调整。一个基类可以派生出多个派生类，每一个派生类又可以作为基类再派生出新的派生类，因此基类和派生类是相对而言的。

	以上介绍的是最简单的情况: 一个派生类只从一个基类派生，这称为单继承(single inheritance)，

	一个派生类不仅可以从一个基类派生，也可以从多个基类派生。一个派生类有两个或多个基类的称为多重继承(multiple inheritance)

	派生类是基类的具体化，而基类则是派生类的抽象。


3. 派生类的声明方式

	假设已经声明了一个基类Student，在此基础上通过单继承建立一个派生类Student1:
	class Student1: public Student//声明基类是Student
	{public:
	void display_1( )                          //新增加的成员函数
	{cout<<″age: ″<<age<<endl;
	cout<<″address: ″<<addr<<endl;}
	private:
	int age;                               //新增加的数据成员
	string addr;                           //新增加的数据成员
	};

	基类名前面有public的称为“公用继承(public inheritance)”。

	声明派生类的一般形式为
	class 派生类名: ［继承方式］ 基类名
	{
	派生类新增加的成员
	} ;

	继承方式包括: public(公用的),private(私有的)和protected(受保护的)，此项是可选的，如果不写此项，则默认为private(私有的)。

4. 派生类的构成

	派生类中的成员包括从基类继承过来的成员和自己增加的成员两大部分。在基类中包括数据成员和成员函数(或称数据与方法)两部分，派生类分为两大部分: 一部分是从基类继承来的成员，另一部分是在声明派生类时增加的部分。每一部分均分别包括数据成员和成员函数。


	实际上，并不是把基类的成员和派生类自己增加的成员简单地加在一起就成为派生类。构造一个派生类包括以下3部分工作: 
	(1) 从基类接收成员。派生类把基类全部的成员(不包括构造函数和析构函数)接收过来，也就是说是没有选择的，不能选择接收其中一部分成员，而舍弃另一部分成员。
	要求我们根据派生类的需要慎重选择基类，使冗余量最小。事实上，有些类是专门作为基类而设计的，在设计时充分考虑到派生类的要求。
	(2) 调整从基类接收的成员。接收基类成员是程序人员不能选择的，但是程序人员可以对这些成员作某些调整。
	(3) 在声明派生类时增加的成员。这部分内容是很重要的，它体现了派生类对基类功能的扩展。要根据需要仔细考虑应当增加哪些成员，精心设计。
	此外，在声明派生类时，一般还应当自己定义派生类的构造函数和析构函数，因为构造函数和析构函数是不能从基类继承的。

	派生类是基类定义的延续。可以先声明一个基类，在此基类中只提供某些最基本的功能，而另外有些功能并未实现，然后在声明派生类时加入某些具体的功能，形成适用于某一特定应用的派生类。通过对基类声明的延续，将一个抽象的基类转化成具体的派生类。因此，派生类是抽象基类的具体实现。

5. 派生类成员的访问属性

	在派生类中，对基类的继承方式可以有public(公用的)，private(私有的)和protected(保护的)3种。不同的继承方式决定了基类成员在派生类中的访问属性。
	简单地说: 
	（1） 公用继承(public inheritance)
	基类的公用成员和保护成员在派生类中保持原有访问属性，其私有成员仍为基类私有。
	（2） 私有继承(private inheritance)
	基类的公用成员和保护成员在派生类中成了私有成员。其私有成员仍为基类私有。

	（3） 受保护的继承(protected inheritance)
	基类的公用成员和保护成员在派生类中成了保护成员，其私有成员仍为基类私有。
	保护成员的意思是: 不能被外界引用，但可以被派生类的成员引用



6. 公用继承 

	在定义一个派生类时将基类的继承方式指定为public的，称为公用继承，用公用继承方式建立的派生类称为公用派生类(public derived class)，其基类称为公用基类(public base class)。

	采用公用继承方式时，基类的公用成员和保护成员在派生类中仍然保持其公用成员和保护成员的属性，而基类的私有成员在派生类中并没有成为派生类的私有成员，它仍然是基类的私有成员，只有基类的成员函数可以引用它，而不能被派生类的成员函数引用，因此就成为派生类中的不可访问的成员。


7. 私有继承

	在声明一个派生类时将基类的继承方式指定为private的，称为私有继承，用私有继承方式建立的派生类称为私有派生类(private derived class) ，其基类称为私有基类(private base class)。

	私有基类的公用成员和保护成员在派生类中的访问属性相当于派生类中的私有成员，即派生类的成员函数能访问它们，而在派生类外不能访问它们。私有基类的私有成员在派生类中成为不可访问的成员，只有基类的成员函数可以引用它们。一个基类成员在基类中的访问属性和在派生类中的访问属性可能是不同的。

	由于私有派生类限制太多，使用不方便，一般不常使用。

8. 保护成员和保护继承

	由protected声明的成员称为“受保护的成员”，或简称“保护成员”。从类的用户角度来看，保护成员等价于私有成员。但有一点与私有成员不同，保护成员可以被派生类的成员函数引用。

	如果基类声明了私有成员，那么任何派生类都是不能访问它们的，若希望在派生类中能访问它们，应当把它们声明为保护成员。如果在一个类中声明了保护成员，就意味着该类可能要用作基类，在它的派生类中会访问这些成员。

	在定义一个派生类时将基类的继承方式指定为protected的，称为保护继承，用保护继承方式建立的派生类称为保护派生类(protected derived class)，其基类称为受保护的基类(protected base class)，简称保护基类。

	保护继承的特点是: 保护基类的公用成员和保护成员在派生类中都成了保护成员，其私有成员仍为基类私有。也就是把基类原有的公用成员也保护起来，不让类外任意访问。

	在派生类中，成员有4种不同的访问属性:  
	① 公用的，派生类内和派生类外都可以访问。
	② 受保护的，派生类内可以访问，派生类外不能访问，其下一层的派生类可以访问。
	③ 私有的，派生类内可以访问，派生类外不能访问。
	④ 不可访问的，派生类内和派生类外都不能访问。


9. 多级派生时的访问属性

	在派生类中是不能访问基类的私有成员的，私有成员只能被本类的成员函数所访问，毕竟派生类与基类不是同一个类。如果在多级派生时都采用公用继承方式，那么直到最后一级派生类都能访问基类的公用成员和保护成员。如果采用私有继承方式，经过若干次派生之后，基类的所有的成员已经变成不可访问的了。如果采用保护继承方式，在派生类外是无法访问派生类中的任何成员的。而且经过多次派生后，人们很难清楚地记住哪些成员可以访问，哪些成员不能访问，很容易出错。因此，在实际中，常用的是公用继承。


10. 派生类的构造函数和析构函数

	用户在声明类时可以不定义构造函数，系统会自动设置一个默认的构造函数，在定义类对象时会自动调用这个默认的构造函数。这个构造函数实际上是一个空函数，不执行任何操作。如果需要对类中的数据成员初始化，应自己定义构造函数。

	构造函数的主要作用是对数据成员初始化。在设计派生类的构造函数时，不仅要考虑派生类所增加的数据成员的初始化，还应当考虑基类的数据成员初始化。也就是说，希望在执行派生类的构造函数时，使派生类的数据成员和基类的数据成员同时都被初始化。解决这个问题的思路是: 在执行派生类的构造函数时，调用基类的构造函数。

	任何派生类都包含基类的成员，简单的派生类只有一个基类，而且只有一级派生(只有直接派生类，没有间接派生类)，在派生类的数据成员中不包含基类的对象(即子对象)。

	例11.5 简单的派生类的构造函数。
	#include <iostream>
	#include<string>
	using namespace std;
	class Student//声明基类Student 
	 {public:                                       
	   Student(int n,string nam,char s)           //基类构造函数
	    {num=n;
	     name=nam;
	     sex=s; }
	~Student( ){ }                                 //基类析构函数
	   protected:                                     //保护部分
	    int num;
	    string name;
	    char sex ;                                 
	};

	class Student1: public Student      //声明派生类Student1
	 {public:                           //派生类的公用部分
	   Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s) 
	 //派生类构造函数
	{age=a;                        //在函数体中只对派生类新增的数据成员初始化
	     addr=ad;
	}
	   void show( )
	    {cout<<″num: ″<<num<<endl;
	     cout<<″name: ″<<name<<endl;
	     cout<<″sex: ″<<sex<<endl;
	     cout<<″age: ″<<age<<endl;
	     cout<<″address: ″<<addr<<endl<<endl;
	    }
	   ~Student1( ){ }                         //派生类析构函数
	  private:                               //派生类的私有部分
	   int age;                          
	   string addr;                
	 };

	int main( )
	 {Student1 stud1(10010,″Wang-li″,′f′,19,″115 Beijing Road,Shanghai″);
	  Student1 stud2(10011,″Zhang-fun″,′m′,21,″213 Shanghai Road,Beijing″);
	  stud1.show( );                          //输出第一个学生的数据
	  stud2.show( );                          //输出第二个学生的数据
	  return 0;
	}
	运行结果为
	num:10010
	name:Wang-li
	sex:f
	address: 115 Beijing Road,Shanghai

	num:10011
	name:Zhang-fun
	sex:m
	address: 213 Shanghai Road,Beijing


	请注意派生类构造函数首行的写法:
	Student1(int n，string nam，char s，int a，string ad):Student(n，nam，s)

	其一般形式为
	派生类构造函数名（总参数表列）: 基类构造函数名（参数表列）
	  {派生类中新增数据成员初始化语句}

	可以将对age和addr的初始化也用初始化表处理，将构造函数改写为以下形式: 
	Student1(int n, string nam,char s,int a, string ad):Student(n,nam,s),age(a),addr(ad){}
	这样函数体为空，更显得简单和方便。
	在建立一个对象时，执行构造函数的顺序是: 
    ① 派生类构造函数先调用基类构造函数；
    ② 再执行派生类构造函数本身(即派生类构造函数的函数体)。
    对上例来说，先初始化num，name，sex，然后再初始化age和addr。
	在派生类对象释放时，先执行派生类析构函数~Student1( )，再执行其基类析构函数~Student( )。

11. 有子对象的派生类的构造函数 (不讲)

	类的数据成员中还可以包含类对象，如可以在声明一个类时包含这样的数据成员: 
	Student s1;// Student是已声明的类名，s1是Student类的对象
	这时，s1就是类对象中的内嵌对象，称为子对象(subobject)，即对象中的对象。

	（1） 对基类数据成员初始化；
	（2） 对子对象数据成员初始化；
	（3） 对派生类数据成员初始化。
	程序中派生类构造函数首部如下：
	Student1(int n, string nam,int n1, string nam1,int a, string ad):
	Student(n,nam),monitor(n1,nam1)

12. 多层派生时的构造函数

	一个类不仅可以派生出一个派生类，派生类还可以继续派生，形成派生的层次结构。在上面叙述的基础上，不难写出在多级派生情况下派生类的构造函数。


	多级派生情况下派生类的构造函数。
	#include <iostream>
	#include<string>
	using namespace std;
	class Student//声明基类
	 {public:                                  //公用部分
	   Student(int n, string nam )            //基类构造函数
	    {num=n;
	     name=nam;
	    }
	   void display( )                           //输出基类数据成员
	    {cout<<″num:″<<num<<endl;
	     cout<<″name:″<<name<<endl;
	    }
	  protected:                                //保护部分
	    int num;                                //基类有两个数据成员
	    string name;
	};

	class Student1: public Student               //声明公用派生类Student1
	 {public:
	   Student1(int n,char nam[10],int a):Student(n,nam)//派生类构造函数
	    {age=a; }                         //在此处只对派生类新增的数据成员初始化
	   void show( )                               //输出num，name和age
	    {display( );                               //输出num和name
	     cout<<″age: ″<<age<<endl;
	    }
	   private:                                   //派生类的私有数据
	    int age;                                  //增加一个数据成员
	  };

	class Student2:public Student1               //声明间接公用派生类Student2
	 {public:
	//下面是间接派生类构造函数
	   Student2(int n, string nam,int a,int s):Student1(n,nam,a)
	{score=s;}
	   void show_all( )                              //输出全部数据成员
	{show( );                                    //输出num和name 
	     cout<<″score:″<<score<<endl;               //输出age
	    }
	  private:
	   int score;                                   //增加一个数据成员
	 };

	int main( )
	 {Student2 stud(10010,″Li″,17,89);
	  stud.show_all( );                            //输出学生的全部数据
	return 0;
	 }
	运行时的输出如下: 
	num:10010
	name:Li
	age:17
	score:89  


	基类的构造函数首部: 
	Student(int n, string nam)
	派生类Student1的构造函数首部: 
	Student1(int n, string nam],int a):Student(n,nam)      
	派生类Student2的构造函数首部: 
	Student2(int n, string nam,int a,int s):Student1(n,nam,a)
	在声明Student2类对象时，调用Student2构造函数；在执行Student2构造函数时，先调用Student1构造函数；在执行Student1构造函数时，先调用基类Student构造函数。初始化的顺序是: 
	① 先初始化基类的数据成员num和name。
	② 再初始化Student1的数据成员age。
	③ 最后再初始化Student2的数据成员score。

13.派生类构造函数的特殊形式

	在使用派生类构造函数时，有以下特殊的形式: 
	(1) 当不需要对派生类新增的成员进行任何初始化操作时，派生类构造函数的函数体可以为空，即构造函数是空函数，如例11.6程序中派生类Student1构造函数可以改写为
	Student1(int n, strin nam,int n1, strin nam1):Student(n,nam), monitor(n1,nam1) { }
	此派生类构造函数的作用只是为了将参数传递给基类构造函数和子对象，并在执行派生类构造函数时调用基类构造函数和子对象构造函数。在实际工作中常见这种用法。

	(2) 如果在基类中没有定义构造函数，或定义了没有参数的构造函数，那么在定义派生类构造函数时可不写基类构造函数。因为此时派生类构造函数没有向基类构造函数传递参数的任务。调用派生类构造函数时系统会自动首先调用基类的默认构造函数。
	如果在基类和子对象类型的声明中都没有定义带参数的构造函数，而且也不需对派生类自己的数据成员初始化，则可以不必显式地定义派生类构造函数。因为此时派生类构造函数既没有向基类构造函数和子对象构造函数传递参数的任务，也没有对派生类数据成员初始化的任务。在建立派生类对象时，系统会自动调用系统提供的派生类的默认构造函数，并在执行派生类默认构造函数的过程中，调用基类的默认构造函数和子对象类型默认构造函数。

	如果在基类或子对象类型的声明中定义了带参数的构造函数，那么就必须显式地定义派生类构造函数，并在派生类构造函数中写出基类或子对象类型的构造函数及其参数表。
	如果在基类中既定义无参的构造函数，又定义了有参的构造函数(构造函数重载)，则在定义派生类构造函数时，既可以包含基类构造函数及其参数，也可以不包含基类构造函数。在调用派生类构造函数时，根据构造函数的内容决定调用基类的有参的构造函数还是无参的构造函数。编程者可以根据派生类的需要决定采用哪一种方式。

14.派生类的析构函数

	在派生时，派生类是不能继承基类的析构函数的，也需要通过派生类的析构函数去调用基类的析构函数。在派生类中可以根据需要定义自己的析构函数，用来对派生类中所增加的成员进行清理工作。基类的清理工作仍然由基类的析构函数负责。在执行派生类的析构函数时，系统会自动调用基类的析构函数和子对象的析构函数，对基类和子对象进行清理。
	
	调用的顺序与构造函数正好相反: 先执行派生类自己的析构函数，对派生类新增加的成员进行清理，然后调用子对象的析构函数，对子对象进行清理，最后调用基类的析构函数，对基类进行清理。

15.多重继承（了解）
	
	前面讨论的是单继承，即一个类是从一个基类派生而来的。实际上，常常有这样的情况: 一个派生类有两个或多个基类，派生类从两个或多个基类中继承所需的属性。C++为了适应这种情况，允许一个派生类同时继承多个基类。这种行为称为多重继承(multiple inheritance)。


	如果已声明了类A、类B和类C，可以声明多重继承的派生类D:
	class D:public A,private B,protected C
	{类D新增加的成员}
	D是多重继承的派生类，它以公用继承方式继承A类，以私有继承方式继承B类，以保护继承方式继承C类。D按不同的继承方式的规则继承A,B,C的属性，确定各基类的成员在派生类中的访问权限。

	多重继承派生类的构造函数形式与单继承时的构造函数形式基本相同，只是在初始表中包含多个基类构造函数。如
	派生类构造函数名(总参数表列): 基类1构造函数(参数表列), 基类2构造函数(参数表列), 基类3构造函数 (参数表列)
	 {派生类中新增数成员据成员初始化语句}
	各基类的排列顺序任意。派生类构造函数的执行顺序同样为: 先调用基类的构造函数，再执行派生类构造函数的函数体。调用基类构造函数的顺序是按照声明派生类时基类出现的顺序。


16. 多重继承引起的二义性问题（了解）

	多重继承可以反映现实生活中的情况，能够有效地处理一些较复杂的问题，使编写程序具有灵活性，但是多重继承也引起了一些值得注意的问题，它增加了程序的复杂度，使程序的编写和维护变得相对困难，容易出错。其中最常见的问题就是继承的成员同名而产生的二义性(ambiguous)问题。

	
	规则是: 基类的同名成员在派生类中被屏蔽，成为“不可见”的，或者说，派生类新增加的同名成员覆盖了基类中的同名成员。因此如果在定义派生类对象的模块中通过对象名访问同名的成员，则访问的是派生类的成员。请注意: 不同的成员函数，只有在函数名和参数个数相同、类型相匹配的情况下才发生同名覆盖，如果只有函数名相同而参数不同，不会发生同名覆盖，而属于函数重载。

	要在派生类外访问基类A中的成员，应指明作用域A，写成以下形式: 
	c1.A::a=3;//表示是派生类对象c1中的基类A中的数据成员a
	c1.A::display();     //表示是派生类对象c1中的基类A中的成员函数display


17. 虚基类

 17.1 虚基类的作用
	从上面的介绍可知: 如果一个派生类有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接共同基类数据成员的多份同名成员。在引用这些同名的成员时，必须在派生类对象名后增加直接基类名，以避免产生二义性，使其惟一地标识一个成员，如c1.A::display( )。
	在一个类中保留间接共同基类的多份同名成员，这种现象是人们不希望出现的。
	C++提供虚基类(virtual base class)的方法，使得在继承间接共同基类时只保留一份成员。

	现在，将类A声明为虚基类，方法如下: 
	class A//声明基类A
	 {…};
	class B :virtual public A           //声明类B是类A的公用派生类，A是B的虚基类
	 {…};
	class C :virtual public A           //声明类C是类A的公用派生类，A是C的虚基类
	 {…};
	注意: 虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式时声明的。因为一个基类可以在生成一个派生类时作为虚基类，而在生成另一个派生类时不作为虚基类。声明虚基类的一般形式为

	class 派生类名: virtual 继承方式 基类名
	经过这样的声明后，当基类通过多条派生路径被一个派生类继承时，该派生类只继承该基类一次。

	需要注意: 为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类。否则仍然会出现对基类的多次继承。


 17.2 虚基类的初始化
	如果在虚基类中定义了带参数的构造函数，而且没有定义默认构造函数，则在其所有派生类(包括直接派生或间接派生的派生类)中，通过构造函数的初始化表对虚基类进行初始化。例如
	class A//定义基类A
	 {A(int i){ }                         //基类构造函数，有一个参数
	…};
	class B :virtual public A           //A作为B的虚基类
	 {B(int n):A(n){ }                   //B类构造函数，在初始化表中对虚基类初始化
	…};
	class C :virtual public A           //A作为C的虚基类
	 {C(int n):A(n){ }                   //C类构造函数，在初始化表中对虚基类初始化
	…};
	class D :public B,public C     //类D的构造函数，在初始化表中对所有基类初始化
	 {D(int n):A(n),B(n),C(n){ }
	…};

	注意: 在定义类D的构造函数时，与以往使用的方法有所不同。规定: 在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类初始化。
	C++编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类(如类B和类C) 对虚基类的构造函数的调用，这就保证了虚基类的数据成员不会被多次初始化。

	示例： 在Teacher类和Student类之上增加一个共同的基类Person，如图11.25所示。作为人员的一些基本数据都放在Person中，在Teacher类和Student类中再增加一些必要的数据。
	#include <iostream>
	#include <string>
	using namespace std;
	//声明公共基类Person
	class Person
	{public:
	Person(string nam,char s,int a)//构造函数
	{name=nam;sex=s;age=a;}
	protected:                                        //保护成员
	   string name;
	   char sex;
	   int age;
	};

	//声明Person的直接派生类Teacher
	class Teacher:virtual public Person                //声明Person为公用继承的虚基类
	{public:                                 
	   Teacher(string nam,char s,int a, string t):Person(nam,s,a)//构造函数
	    {title=t; 
	    }
	protected:                                       //保护成员
	    string title;                                  //职称
	};

	//声明Person的直接派生类Student
	class Student:virtual public Person               //声明Person为公用继承的虚基类
	{public:
	Student(string nam,char s,int a,float sco)      //构造函数
	      :Person(nam,s,a),score(sco){ }                //初始化表
	protected:                                       //保护成员
	    float score;                                   //成绩
	 };

	//声明多重继承的派生类Graduate
	class Graduate:public Teacher,public Student   //Teacher和Student为直接基类
	{public:
	Graduate(string nam,char s,int a, string t,float sco,float w)//构造函数
	:Person(nam,s,a),Teacher(nam,s,a,t),Student(nam,s,a,sco),wage(w){}
	//初始化表
	    void show( )                                             //输出研究生的有关数据
	    {cout<<″name:″<<name<<endl;
	     cout<<″age:″<<age<<endl;
	     cout<<″sex:″<<sex<<endl;
	     cout<<″score:″<<score<<endl;
	     cout<<″title:″<<title<<endl;
	     cout<<″wages:″<<wage<<endl;
	     }
	private:
	    float wage;                     //工资
	 };

	//主函数 
	int main( )
	{Graduate grad1(″Wang-li″,′f′,24,″assistant″,89.5,1234.5); 
	grad1.show( );
	return 0;
	}
	运行结果为
	name: Wang-li 
	age:24
	sex:f
	score:89.5
	title:assistant
	wages:1234.5

	可以看到: 使用多重继承时要十分小心，经常会出现二义性问题。许多专业人员认为: 不要提倡在程序中使用多重继承，只有在比较简单和不易出现二义性的情况或实在必要时才使用多重继承，能用单一继承解决的问题就不要使用多重继承。也是由于这个原因，有些面向对象的程序设计语言(如Java，Smalltalk)并不支持多重继承。

18.基类与派生类的转换

	只有公用派生类才是基类真正的子类型，它完整地继承了基类的功能。
	基类与派生类对象之间有赋值兼容关系，由于派生类中包含从基类继承的成员，因此可以将派生类的值赋给基类对象，在用到基类对象的时候可以用其子类对象代替。具体表现在以下几个方面: 
	
	(1) 派生类对象可以向基类对象赋值。
	可以用子类(即公用派生类)对象对其基类对象赋值。如
	A a1;              //定义基类A对象a1
	B b1;                //定义类A的公用派生类B的对象b1
	a1=b1;               //用派生类B对象b1对基类对象a1赋值
	在赋值时舍弃派生类自己的成员。实际上，所谓赋值只是对数据成员赋值，对成员函数不存在赋值问题。 

	请注意: 赋值后不能企图通过对象a1去访问派生类对象b1的成员，因为b1的成员与a1的成员是不同的。假设age是派生类B中增加的公用数据成员，分析下面的用法:
	
	a1.age=23;//错误，a1中不包含派生类中增加的成员
	b1.age=21;                 //正确，b1中包含派生类中增加的成员
	应当注意，子类型关系是单向的、不可逆的。B是A的子类型，不能说A是B的子类型。只能用子类对象对其基类对象赋值，而不能用基类对象对其子类对象赋值，理由是显然的，因为基类对象不包含派生类的成员，无法对派生类的成员赋值。同理，同一基类的不同派生类对象之间也不能赋值。

	(2) 派生类对象可以替代基类对象向基类对象的引用进行赋值或初始化。
	如已定义了基类A对象a1，可以定义a1的引用变量:
	A a1;           //定义基类A对象a1
	B b1;                //定义公用派生类B对象b1
	A& r=a1;             //定义基类A对象的引用变量r，并用a1对其初始化
	这时，引用变量r是a1的别名，r和a1共享同一段存储单元。也可以用子类对象初始化引用变量r，将上面最后一行改为
	A& r=b1;//定义基类A对象的引用变量r，并用派生类B对象b1
	//对其初始化
	或者保留上面第3行“A& r=a1;”，而对r重新赋值：
	r=b1;//用派生类B对象b1对a1的引用变量r赋值

	注意: 此时r并不是b1的别名，也不与b1共享同一段存储单元。它只是b1中基类部分的别名，r与b1中基类部分共享同一段存储单元，r与b1具有相同的起始地址


	(3) 如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象。
	如有一函数fun: 
	void fun(A& r)//形参是类A的对象的引用变量
	 {cout<<r.num<<endl;}            //输出该引用变量的数据成员num
	函数的形参是类A的对象的引用变量，本来实参应该为A类的对象。由于子类对象与派生类对象赋值兼容，派生类对象能自动转换类型，在调用fun函数时可以用派生类B的对象b1作实参: 
	fun(b1);
	输出类B的对象b1的基类数据成员num的值。
	与前相同，在fun函数中只能输出派生类中基类成员的值。

	(4) 派生类对象的地址可以赋给指向基类对象的指针变量，也就是说，指向基类对象的指针变量也可以指向派生类对象。

	通过本例可以看到: 用指向基类对象的指针变量指向子类对象是合法的、安全的，不会出现编译上的错误。但在应用上却不能完全满足人们的希望，人们有时希望通过使用基类指针能够调用基类和子类对象的成员。在下一章就要解决这个问题。办法是使用虚函数和多态性。



19. 继承与组合


20.继承在软件开发中的重要意义

	有了继承，使软件的重用成为可能。继承是C++和C的最重要的区别之一。
	由于C++提供了继承的机制，这就吸引了许多厂商开发各类实用的类库。用户将它们作为基类去建立适合于自己的类(即派生类)，并在此基础上设计自己的应用程序。类库的出现使得软件的重用更加方便，现在有一些类库是随着C++编译系统卖给用户的。读者不要认为类库是C++编译系统的一部分。不同的C++编译系统提供的由不同厂商开发的类库一般是不同的。


	对类库中类的声明一般放在头文件中，类的实现(函数的定义部分)是单独编译的，以目标代码形式存放在系统某一目录下。用户使用类库时，不需要了解源代码，但必须知道头文件的使用方法和怎样去连接这些目标代码(在哪个子目录下)，以便源程序在编译后与之连接。
	由于基类是单独编译的，在程序编译时只需对派生类新增的功能进行编译，这就大大提高了调试程序的效率。如果在必要时修改了基类，只要基类的公用接口不变，派生类不必修改，但基类需要重新编译，派生类也必须重新编译，否则不起作用。

	(1) 有许多基类是被程序的其他部分或其他程序使用的，这些程序要求保留原有的基类不受破坏。
	(2) 用户往往得不到基类的源代码。
	(3) 在类库中，一个基类可能已被指定与用户所需的多种组件建立了某种关系，因此在类库中的基类是不容许修改的。
	(4) 实际上，许多基类并不是从已有的其他程序中选取来的，而是专门作为基类设计的。
	(5) 在面向对象程序设计中，需要设计类的层次结构，从最初的抽象类出发，每一层派生类的建立都逐步地向着目标的具体实现前进。


21. 多态性的概念
	多态性(polymorphism)是面向对象程序设计的一个重要特征。利用多态性可以设计和实现一个易于扩展的系统。

	在C++程序设计中，多态性是指具有不同功能的函数可以用同一个函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性的: 向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为(即方法)。也就是说，每个对象可以用自己的方式去响应共同的消息。

	在C++程序设计中，在不同的类中定义了其响应消息的方法，那么使用这些类时，不必考虑它们是什么类型，只要发布消息即可。

	从系统实现的角度看，多态性分为两类: 静态多态性和动态多态性。以前学过的函数重载和运算符重载实现的多态性属于静态多态性，在程序编译时系统就能决定调用的是哪个函数，因此静态多态性又称编译时的多态性。静态多态性是通过函数的重载实现的(运算符重载实质上也是函数重载)。动态多态性是在程序运行过程中才动态地确定操作所针对的对象。它又称运行时的多态性。动态多态性是通过虚函数(virtual function)实现的。

	有关静态多态性的应用已经介绍过了，在本章中主要介绍动态多态性和虚函数。

	要研究的问题是: 当一个基类被继承为不同的派生类时，各派生类可以使用与基类成员相同的成员名，如果在运行时用同一个成员名调用类对象的成员，会调用哪个对象的成员？也就是说，通过继承而产生了相关的不同的派生类，与基类成员同名的成员在不同的派生类中有不同的含义。也可以说，多态性是“一个接口，多种方法”。


22.虚函数

	基类与派生类中有同名函数。
	在下面的程序中Student是基类，Graduate是派生类，它们都有display这个同名的函数。
	#include <iostream>
	#include <string>
	using namespace std;
	//声明基类Student
	class Student
	{public:
	   Student(int, string,float);//声明构造函数
	   void display( );                                             //声明输出函数
	  protected:                                      //受保护成员，派生类可以访问 
	   int num;
	   string name;
	   float score;
	 };

	//Student类成员函数的实现
	Student::Student(int n, string nam,float s)                     //定义构造函数
	 {num=n;name=nam;score=s;}

	void Student::display( )                                        //定义输出函数
	{cout<<″num:″<<num<<″\\nname:″<<name<<″\\nscore:″<<score<<″\\n\\n″;}

	//声明公用派生类Graduate
	class Graduate:public Student
	{public:
	   Graduate(int, string, float, float);                          //声明构造函数
	   void display( );                                             //声明输出函数
	private:
	  float pay;
	};
	// Graduate类成员函数的实现
	void Graduate::display( )                                       //定义输出函数
	 {cout<<″num:″<<num<<″\\nname:″<<name<<″\\nscore:″<<score<<″\\npay=″<<pay<<endl;}

	Graduate::Graduate(int n, string nam,float s,float p):Student(n,nam,s),pay(p){ }

	//主函数
	int main()
	 {Student stud1(1001,″Li″,87.5);                   //定义Student类对象stud1
	  Graduate grad1(2001,″Wang″,98.5,563.5);          //定义Graduate类对象grad1
	  Student *pt=&stud1;                              //定义指向基类对象的指针变量pt
	  pt->display( );
	  pt=&grad1;
	  pt->display( );
	  return 0;
	 }

	运行结果如下，请仔细分析。
	num:1001(stud1的数据)
	name:Li
	score:87.5

	num:2001                  (grad1中基类部分的数据)
	name:wang
	score:98.5

	下面对程序作一点修改，在Student类中声明display函数时，在最左面加一个关键字virtual，即
	virtual void display( );
	这样就把Student类的display函数声明为虚函数。程序其他部分都不改动。再编译和运行程序，请注意分析运行结果: 
	num:1001(stud1的数据)
	name:Li
	score:87.5
	num:2001                  (grad1中基类部分的数据)
	name:wang
	score:98.5
	pay=1200                   (这一项以前是没有的)

	由虚函数实现的动态多态性就是: 同一类族中不同类的对象，对同一函数调用作出不同的响应。虚函数的使用方法是: 
	(1) 在基类用virtual声明成员函数为虚函数。这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用。
	在类外定义虚函数时，不必再加virtual。

	(2) 在派生类中重新定义此函数，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体。

	C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此在派生类重新声明该虚函数时，可以加virtual，也可以不加，但习惯上一般在每一层声明该函数时都加virtual，使程序更加清晰。
	如果在派生类中没有对基类的虚函数重新定义，则派生类简单地继承其直接基类的虚函数。
	(3) 定义一个指向基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象。
	(4) 通过该指针变量调用此虚函数，此时调用的就是指针变量指向的对象的同名函数。

	通过虚函数与指向基类对象的指针变量的配合使用，就能方便地调用同一类族中不同类的同名函数，只要先用基类指针指向即可。如果指针不断地指向同一类族中不同类的对象，就能不断地调用这些对象中的同名函数。这就如同前面说的，不断地告诉出租车司机要去的目的地，然后司机把你送到你要去的地方。
	需要说明；有时在基类中定义的非虚函数会在派生类中被重新定义(如例12.1中的area函数)，如果用基类指针调用该成员函数，则系统会调用对象中基类部分的成员函数；如果用派生类指针调用该成员函数，则系统会调用派生类对象中的成员函数，这并不是多态性行为(使用的是不同类型的指针),没有用到虚函数的功能。


	以前介绍的函数重载处理的是同一层次上的同名函数问题，而虚函数处理的是不同派生层次上的同名函数问题，前者是横向重载，后者可以理解为纵向重载。但与重载不同的是: 同一类族的虚函数的首部是相同的，而函数重载时函数的首部是不同的(参数个数或类型不同)。



23. 静态关联与动态关联 

	前面所提到的函数重载和通过对象名调用的虚函数，在编译时即可确定其调用的虚函数属于哪一个类，其过程称为静态关联(static binding)，由于是在运行前进行关联的，故又称为早期关联(early binding)。函数重载属静态关联。 

	在运行阶段，指针可以先后指向不同的类对象，从而调用同一类族中不同类的虚函数。由于动态关联是在编译以后的运行阶段进行的，因此也称为滞后关联(late binding)。

24. 声明虚函数的情况
	使用虚函数时，有两点要注意: 
	(1)只能用virtual声明类的成员函数，使它成为虚函数，而不能将类外的普通函数声明为虚函数。因为虚函数的作用是允许在派生类中对基类的虚函数重新定义。显然，它只能用于类的继承层次结构中。
	(2) 一个成员函数被声明为虚函数后，在同一类族中的类就不能再定义一个非virtual的但与该虚函数具有相同的参数(包括个数和类型)和函数返回值类型的同名函数。
	根据什么考虑是否把一个成员函数声明为虚函数呢？主要考虑以下几点: 

	(1) 首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。
	(2) 如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。不要仅仅考虑到要作为基类而把类中的所有成员函数都声明为虚函数。
	(3) 应考虑对成员函数的调用是通过对象名还是通过基类指针或引用去访问，如果是通过基类指针或引用去访问的，则应当声明为虚函数。
	(4) 有时，在定义虚函数时，并不定义其函数体，即函数体是空的。它的作用只是定义了一个虚函数名，具体功能留给派生类去添加。在12.4节中将详细讨论此问题。
	
	需要说明的是: 使用虚函数，系统要有一定的空间开销。当一个类带有虚函数时，编译系统会为该类构造一个虚函数表(virtual function table，简称vtable)，它是一个指针数组，存放每个虚函数的入口地址。系统在进行动态关联时的时间开销是很少的，因此，多态性是高效的。

25. 虚析构函数


	析构函数的作用是在对象撤销之前做必要的“清理现场”的工作。当派生类的对象从内存中撤销时一般先调用派生类的析构函数，然后再调用基类的析构函数。但是，如果用new运算符建立了临时对象，若基类中有析构函数，并且定义了一个指向该基类的指针变量。在程序用带指针参数的delete运算符撤销对象时，会发生一个情况: 系统会只执行基类的析构函数，而不执行派生类的析构函数。

	基类中有非虚析构函数时的执行情况。
	为简化程序，只列出最必要的部分。
	#include <iostream>
	using namespace std;
	class Point//定义基类Point类
	{public:
	  Point( ){ }                                                   //Point类构造函数
	  ~Point(){cout<<″executing Point destructor″<<endl;}//Point类析构函数
	};

	class Circle:public Point                                     //定义派生类Circle类
	{public:
	  Circle( ){ }                                                 //Circle类构造函数
	  ~Circle( ){cout<<″executing Circle destructor″<<endl;}//Circle类析构函数
	 private:
	  int radius;
	};

	int main( )
	{ Point *p=new Circle;                             //用new开辟动态存储空间
	delete p;                                        //用delete释放动态存储空间
	return 0;
	}

	这只是一个示意的程序。p是指向基类的指针变量，指向new开辟的动态存储空间，希望用detele释放p所指向的空间。但运行结果为
	executing Point destructor
	表示只执行了基类Point的析构函数，而没有执行派生类Circle的析构函数。原因是以前介绍过的。如果希望能执行派生类Circle的析构函数，可以将基类的析构函数声明为虚析构函数，如
	virtual ~Point(){cout<<″executing Point destructor″<<endl;}
	程序其他部分不改动，再运行程序，结果为
	executing Circle destructor
	executing Point destructor

	先调用了派生类的析构函数，再调用了基类的析构函数，符合人们的愿望。当基类的析构函数为虚函数时，无论指针指的是同一类族中的哪一个类对象，系统会采用动态关联，调用相应的析构函数，对该对象进行清理工作。
	如果将基类的析构函数声明为虚函数时，由该基类所派生的所有派生类的析构函数也都自动成为虚函数，即使派生类的析构函数与基类的析构函数名字不相同。
	最好把基类的析构函数声明为虚函数。这将使所有派生类的析构函数自动成为虚函数。这样，如果程序中显式地用了delete运算符准备删除一个对象，而delete运算符的操作对象用了指向派生类对象的基类指针，则系统会调用相应类的析构函数。

	虚析构函数的概念和用法很简单，但它在面向对象程序设计中却是很重要的技巧。专业人员一般都习惯声明虚析构函数，即使基类并不需要析构函数，也显式地定义一个函数体为空的虚析构函数，以保证在撤销动态分配空间时能得到正确的处理。

	构造函数不能声明为虚函数。这是因为在执行构造函数时类对象还未完成建立过程，当然谈不上函数与类对象的绑定。


26. 纯虚函数与抽象类

 26.1 纯虚函数
 
	有时在基类中将某一成员函数定为虚函数，并不是基类本身的要求，而是考虑到派生类的需要，在基类中预留了一个函数名，具体功能留给派生类根据需要去定义。

	纯虚函数是在声明虚函数时被“初始化”为0的函数。声明纯虚函数的一般形式是
	virtual 函数类型 函数名 (参数表列) =0;

	注意: 
        ① 纯虚函数没有函数体；
        ② 最后面的“=0”并不表示函数返回值为0，它只起形式上的作用，告诉编译系统“这是纯虚函数”; 
        ③ 这是一个声明语句，最后应有分号。

	纯虚函数只有函数的名字而不具备函数的功能，不能被调用。它只是通知编译系统: “在这里声明一个虚函数，留待派生类中定义”。在派生类中对此函数提供定义后，它才能具备函数的功能，可被调用。
	纯虚函数的作用是在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。如果在基类中没有保留函数名字，则无法实现多态性。
	如果在一个类中声明了纯虚函数，而在其派生类中没有对该函数定义，则该虚函数在派生类中仍然为纯虚函数。

 26.2 抽象类

	如果声明了一个类，一般可以用它定义对象。但是在面向对象程序设计中，往往有一些类，它们不用来生成对象。定义这些类的惟一目的是用它作为基类去建立派生类。它们作为一种基本类型提供给用户，用户在这个基础上根据自己的需要定义出功能各异的派生类。用这些派生类去建立对象。

	一个优秀的软件工作者在开发一个大的软件时，决不会从头到尾都由自己编写程序代码，他会充分利用已有资源(例如类库)作为自己工作的基础。
	这种不用来定义对象而只作为一种基本类型用作继承的类，称为抽象类(abstract class)，由于它常用作基类，通常称为抽象基类(abstract base class)。

	凡是包含纯虚函数的类都是抽象类。因为纯虚函数是不能被调用的，包含纯虚函数的类是无法建立对象的。抽象类的作用是作为一个类族的共同基类，或者说，为一个类族提供一个公共接口。

	一个类层次结构中当然也可不包含任何抽象类，每一层次的类都是实际可用的，可以用来建立对象的。但是，许多好的面向对象的系统，其层次结构的顶部是一个抽象类，甚至顶部有好几层都是抽象类。

	如果在抽象类所派生出的新类中对基类的所有纯虚函数进行了定义，那么这些函数就被赋予了功能，可以被调用。这个派生类就不是抽象类，而是可以用来定义对象的具体类(concrete class)。如果在派生类中没有对所有纯虚函数进行定义，则此派生类仍然是抽象类，不能用来定义对象。

	虽然抽象类不能定义对象(或者说抽象类不能实例化)，但是可以定义指向抽象类数据的指针变量。当派生类成为具体类之后，就可以用这种指针指向派生类对象，然后通过该指针调用虚函数，实现多态性的操作。



27. 栈

标准模板库  模板类

    C++ Stacks（堆栈）
    C++ Stack（堆栈） 是一个容器类的改编，为程序员提供了堆栈的全部功能，——也就是说实现了一个先进后出（FILO）的数据结构。
    
    操作 比较和分配堆栈 
    empty() 堆栈为空则返回真 
    pop() 移除栈顶元素 
    push() 在栈顶增加元素 
    size() 返回栈中元素数目 
    top() 返回栈顶元素 
    
28. 队列
    C++ Queues(队列)
    C++队列是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构。 
    
    back() 返回最后一个元素 
    empty() 如果队列空则返回真 
    front() 返回第一个元素 
    pop() 删除第一个元素 
    push() 在末尾加入一个元素 
    size() 返回队列中元素的个数 
    
    

